<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>LabelGen Pro</title>
    
    <link rel="icon" href='data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="%23174034" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 6 2 18 2 18 9"/><path d="M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2"/><rect width="12" height="8" x="6" y="14"/></svg>'>

    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    
    <!-- Babel for browser-side compilation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script>
      tailwind.config = {
        theme: {
          extend: {
            fontFamily: {
              sans: ['Inter', 'sans-serif'],
            },
            colors: {
              brand: {
                green: '#174034',
                pink: '#E67E8C',
                gray: '#F3F4F6'
              }
            }
          }
        }
      }
    </script>
    <script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@18.2.0",
    "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
    "lucide-react": "https://esm.sh/lucide-react@0.294.0",
    "jspdf": "https://esm.sh/jspdf@2.5.1",
    "react-dom/": "https://esm.sh/react-dom@^19.2.4/"
  }
}
</script>
</head>
  <body class="bg-gray-50 text-gray-900 antialiased">
    <div id="root"></div>
    
    <!-- Inline Application Script -->
    <script type="text/babel" data-type="module" data-presets="react,typescript">
      import React, { useState, useEffect } from 'react';
      import ReactDOM from 'react-dom/client';
      import { ClipboardPaste, AlertCircle, ArrowRight, Printer, RefreshCcw, Settings2, Info } from 'lucide-react';
      import { jsPDF } from "jspdf";

      // --- TYPES ---
      interface LabelData {
        id: string;
        customerName: string;
        dishLetter: string;
        dishType: string;
        dishName: string;
        allergens: string;
        brand: string;
        quantity: number;
      }

      // --- PDF SERVICE ---
      const createPDFDoc = (data) => {
        const doc = new jsPDF({ orientation: "portrait", unit: "mm", format: "a4" });
        const columns = 3; const rows = 7; const itemsPerPage = columns * rows;
        const boxWidth = 63; const boxHeight = 38; const cornerRadius = 2;
        const horizontalGap = 3; const verticalGap = 0;
        const startX = 7; const startY = 15.5;

        const expandedData = [];
        data.forEach(item => {
          const qty = item.quantity > 0 ? item.quantity : 1;
          for (let i = 0; i < qty; i++) expandedData.push(item);
        });

        expandedData.forEach((item, index) => {
          if (index > 0 && index % itemsPerPage === 0) doc.addPage();
          const positionOnPage = index % itemsPerPage;
          const colIndex = positionOnPage % columns;
          const rowIndex = Math.floor(positionOnPage / columns);
          const x = startX + (colIndex * (boxWidth + horizontalGap));
          const y = startY + (rowIndex * (boxHeight + verticalGap));

          // Box Border
          doc.setDrawColor(200, 200, 200);
          doc.setLineWidth(0.1);
          doc.roundedRect(x, y, boxWidth, boxHeight, cornerRadius, cornerRadius, "S");

          const centerX = x + (boxWidth / 2);

          // 1. Customer Name (Centered, First Letter Double Size)
          const customerName = (item.customerName || "").toUpperCase();
          if (customerName) {
            const firstChar = customerName.charAt(0);
            const rest = customerName.slice(1);

            doc.setFont("helvetica", "bold");
            doc.setTextColor(23, 64, 52);

            doc.setFontSize(24);
            const w1 = doc.getTextWidth(firstChar);

            doc.setFontSize(12);
            const w2 = doc.getTextWidth(rest);

            const totalWidth = w1 + w2;
            const textStartX = centerX - (totalWidth / 2);

            doc.setFontSize(24);
            doc.text(firstChar, textStartX, y + 9);

            doc.setFontSize(12);
            doc.text(rest, textStartX + w1, y + 9);
          } else {
             doc.setFont("helvetica", "bold");
             doc.setTextColor(23, 64, 52);
             doc.setFontSize(14);
             doc.text("CUSTOMER", centerX, y + 9, { align: "center" });
          }

          // 2. Dish Name
          const dishName = item.dishName || "";
          doc.setFont("helvetica", "normal");
          doc.setFontSize(10);
          doc.setTextColor(0, 0, 0);
          const contentLines = doc.splitTextToSize(dishName, boxWidth - 6);
          const displayLines = contentLines.length > 2 ? contentLines.slice(0, 2) : contentLines;
          doc.text(displayLines, centerX, y + 14, { align: "center" });

          // 3. Dish Letter (Circle or Box for Addons)
          const dishLetter = (item.dishLetter || "A").toUpperCase();
          const isLongText = dishLetter.length > 2;

          doc.setDrawColor(230, 126, 140); // Pink Border
          doc.setTextColor(230, 126, 140); // Pink Text
          doc.setLineWidth(0.4);

          if (isLongText) {
             // Draw Box (Rounded Rectangle to cover "ADDONS")
             doc.setFontSize(10);
             const textWidth = doc.getTextWidth(dishLetter);
             const padding = 3;
             const boxW = Math.max(textWidth + (padding * 2), 12);
             const boxH = 8;
             const rectX = centerX - (boxW / 2);
             const rectY = y + 20; // Vertically centered roughly where the circle was

             doc.roundedRect(rectX, rectY, boxW, boxH, 1, 1, "S");
             
             // Center text in box
             doc.text(dishLetter, centerX, rectY + 5.5, { align: "center" });
          } else {
             // Draw Circle (Original Logic)
             const circleY = y + 24;
             const circleRadius = 4;
             doc.circle(centerX, circleY, circleRadius, "S");

             doc.setFont("helvetica", "bold");
             doc.setFontSize(13);
             doc.text(dishLetter, centerX, circleY + 1.5, { align: "center", baseline: "bottom" });
          }

          // 4. Allergens
          const allergens = (item.allergens || "").toUpperCase();
          if (allergens) {
            doc.setFont("helvetica", "bold");
            doc.setFontSize(6);
            doc.setTextColor(230, 126, 140);
            doc.text(allergens, centerX, y + 32, { align: "center" });
          }

          // 5. Restaurant (Footer)
          const brandText = (item.brand || "RESTAURANT").toUpperCase();
          doc.setFont("helvetica", "bold");
          doc.setFontSize(7);
          doc.setTextColor(0, 0, 0);
          doc.text(brandText, centerX, y + 36, { align: "center" });
        });

        return doc;
      };

      const printPDF = (data) => { 
        try {
          const doc = createPDFDoc(data); 
          
          // Add autoPrint script to the PDF so it triggers print dialog when opened
          doc.autoPrint();
          
          // Generate Blob
          const blob = doc.output("blob");
          const url = URL.createObjectURL(blob);
          
          // Open in new tab - this is the most reliable way to print
          const printWindow = window.open(url, '_blank');
          
          if (!printWindow) {
            alert("Please allow popups to open the print dialog.");
          }
        } catch (e) {
          console.error("Print Error:", e);
          alert("An error occurred while preparing the print document.");
        }
      };

      // --- COMPONENTS ---

      const FileUpload = ({ onDataLoaded }) => {
        const [jsonText, setJsonText] = useState("");
        const [error, setError] = useState(null);

        const handleProcess = () => {
          setError(null);
          if (!jsonText.trim()) { setError("Paste JSON data."); return; }
          try {
            const cleanText = jsonText.replace(/[\u201C\u201D]/g, '"').replace(/[\u2018\u2019]/g, "'");
            const json = JSON.parse(cleanText);
            if (Array.isArray(json)) onDataLoaded(json);
            else if (typeof json === 'object' && json !== null) onDataLoaded([json]);
            else setError("Must be Array or Object.");
          } catch (err) { setError("Invalid JSON format."); }
        };

        return (
          <div className="w-full max-w-4xl mx-auto mb-8 bg-white rounded-xl shadow-sm border border-gray-200 overflow-hidden">
             <div className="bg-gray-50 p-4 flex items-center gap-2 border-b"><ClipboardPaste className="text-brand-green"/> Paste JSON</div>
             <textarea value={jsonText} onChange={(e) => setJsonText(e.target.value)} className="w-full h-64 p-4 font-mono text-sm border-none focus:ring-0 resize-y outline-none" placeholder="Paste data here..."/>
             <div className="p-4 bg-gray-50 flex justify-between items-center border-t">
               <div className="text-red-500 text-sm">{error}</div>
               <button onClick={handleProcess} className="bg-brand-green text-white px-6 py-2 rounded-lg flex items-center gap-2">Load Data <ArrowRight size={16}/></button>
             </div>
          </div>
        );
      };

      const LabelPreview = ({ data, scale = 1 }) => {
        const rawName = (data.customerName || "").toUpperCase();
        const firstChar = rawName.charAt(0);
        const restOfName = rawName.slice(1);
        
        const dishLetter = (data.dishLetter || "A").toUpperCase();
        const isLongText = dishLetter.length > 2;
        const brandText = (data.brand || "RESTAURANT").toUpperCase();

        return (
          <div className="flex flex-col items-center mx-auto" style={{ transform: `scale(${scale})`, transformOrigin: 'top center', width: '240px' }}>
            <div className="w-full bg-white rounded border border-gray-300 shadow-sm flex flex-col items-center p-2 relative overflow-hidden" style={{ height: '145px' }}>
              
              {/* Customer Name */}
              <div className="w-full flex justify-center items-baseline mt-2 mb-1">
                 <span className="text-brand-green font-extrabold text-4xl leading-none uppercase tracking-tight">{firstChar}</span>
                 <span className="text-brand-green font-extrabold text-xl leading-none uppercase tracking-tight">{restOfName}</span>
              </div>
              
              {/* Dish Name */}
              <div className="w-full flex justify-center mb-2 px-1">
                <p className="text-gray-900 text-center font-medium text-sm leading-tight line-clamp-2">{data.dishName || "Dish Name Content"}</p>
              </div>

              {/* Dish Letter (Pink Border, White Background, Box if long) */}
              <div className="flex-grow flex flex-col justify-center items-center mb-1">
                {isLongText ? (
                   <div className="px-2 h-8 rounded border-2 border-brand-pink flex items-center justify-center bg-white min-w-[32px]">
                      <span className="text-brand-pink font-bold text-xs leading-none uppercase">{dishLetter}</span>
                   </div>
                ) : (
                   <div className="w-8 h-8 rounded-full border-2 border-brand-pink flex items-center justify-center bg-white">
                      <span className="text-brand-pink font-bold text-lg leading-none">{dishLetter}</span>
                   </div>
                )}
                {data.dishType && <span className="text-[10px] text-gray-400 font-semibold uppercase mt-0.5">{data.dishType}</span>}
              </div>

              {/* Allergens */}
              {data.allergens && (
                 <div className="w-full text-center mb-0.5"><p className="text-brand-pink font-bold uppercase text-[9px] truncate px-2">{data.allergens}</p></div>
              )}

              {/* Footer */}
              <div className="w-full text-center border-t border-dashed border-gray-100 pt-1">
                <p className="text-black font-bold uppercase text-[9px] tracking-wide truncate">{brandText}</p>
              </div>
            </div>
          </div>
        );
      };

      const App = () => {
        const [rawData, setRawData] = useState([]);
        const [mappedData, setMappedData] = useState([]);
        const [mapping, setMapping] = useState({ customerName: '', dishLetter: '', dishType: '', dishName: '', allergens: '', brand: '' });
        const [keys, setKeys] = useState([]);
        const [step, setStep] = useState(1);

        const preprocessNestedData = (data) => {
          let flatList = [];
          let isNested = false;
          data.forEach(item => {
            if (item.boxes && Array.isArray(item.boxes)) {
              isNested = true;
              const footerName = item.deliveryName || item.name || "Unknown";
              item.boxes.forEach(box => {
                if (box.dishes && Array.isArray(box.dishes)) {
                  box.dishes.forEach(dish => {
                    const dishName = dish.name || "";
                    const dishLabel = dish.label || "";
                    const recipeType = dish.recipeType || "";
                    const allergens = dish.allergens ? (Array.isArray(dish.allergens) ? dish.allergens.join(", ") : dish.allergens) : "";
                    
                    if (dish.users && Array.isArray(dish.users) && dish.users.length > 0) {
                      dish.users.forEach(user => {
                        const qty = Number(user.orderedQuantity) || 0;
                        const userName = user.username || "";
                        for (let i = 0; i < qty; i++) {
                           flatList.push({ "Customer Name": userName, "Dish Letter": dishLabel, "Dish Type": recipeType, "Dish Name": dishName, "Allergens": allergens, "Restaurant": footerName, _initialQty: 1 });
                        }
                      });
                    } else {
                       flatList.push({ "Customer Name": "", "Dish Letter": dishLabel, "Dish Type": recipeType, "Dish Name": dishName, "Allergens": allergens, "Restaurant": footerName, _initialQty: 1 });
                    }
                  });
                }
              });
            } else flatList.push(item);
          });
          return isNested ? flatList : data;
        };

        const handleDataLoaded = (data) => {
           const processed = preprocessNestedData(data);
           setRawData(processed);
           if(processed.length) {
             const k = Object.keys(processed[0]).filter(k => k !== '_initialQty');
             setKeys(k);
             
             const getKey = (keywords) => k.find(x => keywords.some(w => x.toLowerCase().includes(w))) || '';
             const newMapping = {
                customerName: getKey(['customer', 'user', 'client']),
                dishLetter: getKey(['letter', 'label', 'addon', 'code']),
                dishType: getKey(['type', 'recipe', 'category']),
                dishName: getKey(['dish name', 'item', 'content', 'product']),
                allergens: getKey(['allergen']),
                brand: getKey(['brand', 'company', 'restaurant', 'bellabona'])
             };
             if (!newMapping.dishName) newMapping.dishName = k[0] || '';
             setMapping(newMapping);
             setStep(2);
           }
        };

        useEffect(() => {
           if(!rawData.length) return;
           setMappedData(rawData.map((item, i) => ({
              id: `label-${i}`,
              customerName: item[mapping.customerName] ? String(item[mapping.customerName]) : '',
              dishLetter: item[mapping.dishLetter] ? String(item[mapping.dishLetter]) : '',
              dishType: item[mapping.dishType] ? String(item[mapping.dishType]) : '',
              dishName: item[mapping.dishName] ? String(item[mapping.dishName]) : '',
              allergens: item[mapping.allergens] ? String(item[mapping.allergens]) : '',
              brand: item[mapping.brand] ? String(item[mapping.brand]) : 'BELLABONA',
              quantity: item._initialQty || item.quantity || 1
           })));
        }, [rawData, mapping]);

        const totalLabels = mappedData.reduce((acc, item) => acc + (item.quantity || 1), 0);
        const totalPages = Math.ceil(totalLabels / 21);

        const getRawValue = (obj, key) => {
           if (!obj || !key) return '';
           const val = obj[key];
           return typeof val === 'object' ? JSON.stringify(val) : String(val || '');
        };

        return (
          <div className="min-h-screen bg-gray-50 flex flex-col font-sans">
            <header className="bg-white border-b p-4"><div className="max-w-7xl mx-auto flex items-center gap-2 text-xl font-bold"><Printer className="text-brand-green"/> LabelGen Pro</div></header>
            <main className="max-w-7xl mx-auto p-8 w-full">
               {step === 1 && (
                 <div className="flex flex-col items-center justify-center min-h-[60vh]">
                   <div className="text-center mb-10"><h2 className="text-4xl font-extrabold mb-4">Generate Professional Labels</h2><p>Paste JSON data.</p></div>
                   <FileUpload onDataLoaded={handleDataLoaded} />
                 </div>
               )}
               {step === 2 && (
                 <div className="grid grid-cols-1 lg:grid-cols-12 gap-8">
                    <div className="lg:col-span-5 bg-white p-4 rounded shadow">
                       <h3 className="text-center font-bold mb-4">Preview</h3>
                       <div className="flex justify-center mb-4"><div className="scale-90"><LabelPreview data={{
                          customerName: mapping.customerName ? getRawValue(rawData[0], mapping.customerName) : 'Harsh',
                          dishLetter: mapping.dishLetter ? getRawValue(rawData[0], mapping.dishLetter) : 'ADDONS',
                          dishType: mapping.dishType ? getRawValue(rawData[0], mapping.dishType) : 'Starter',
                          dishName: mapping.dishName ? getRawValue(rawData[0], mapping.dishName) : 'Soup',
                          allergens: mapping.allergens ? getRawValue(rawData[0], mapping.allergens) : 'Gluten',
                          brand: mapping.brand ? getRawValue(rawData[0], mapping.brand) : 'BELLABONA'
                       }}/></div></div>
                       <div className="space-y-4 grid grid-cols-2 gap-4">
                          {[
                             ['customerName', 'Customer'], ['dishLetter', 'Dish Letter'], 
                             ['dishType', 'Dish Type'], ['dishName', 'Dish Name'], 
                             ['allergens', 'Allergens'], ['brand', 'Brand']
                          ].map(([key, label]) => (
                             <div key={key}><label className="text-xs uppercase font-bold">{label}</label><select value={mapping[key]} onChange={e => setMapping({...mapping, [key]: e.target.value})} className="w-full text-sm border rounded"><option value="">(None)</option>{keys.map(k=><option key={k} value={k}>{k}</option>)}</select></div>
                          ))}
                       </div>
                       <button onClick={() => setStep(3)} className="w-full mt-4 bg-brand-green text-white py-2 rounded">Generate</button>
                    </div>
                    <div className="lg:col-span-7 bg-white rounded shadow p-4">
                       <h3>Label Data ({totalLabels})</h3>
                       <div className="max-h-[500px] overflow-auto">
                          <table className="w-full text-sm"><thead><tr><th>#</th><th>Content</th><th>Qty</th></tr></thead><tbody>
                             {mappedData.map((row, i) => (
                                <tr key={i} className="border-b"><td className="p-2">{i+1}</td><td className="p-2 font-bold text-brand-green">{row.customerName} - {row.dishName}</td><td className="p-2"><input type="number" min="1" value={row.quantity} onChange={(e) => {
                                   const next = [...mappedData]; next[i].quantity = parseInt(e.target.value)||1; setMappedData(next);
                                }} className="w-12 border rounded"/></td></tr>
                             ))}
                          </tbody></table>
                       </div>
                    </div>
                 </div>
               )}
               {step === 3 && (
                 <div>
                    <div className="flex justify-between items-center mb-4">
                       <div>
                         <h2 className="text-xl font-bold">Print Labels</h2>
                         <p className="text-xs text-gray-500">Ready to print {totalLabels} labels</p>
                       </div>
                       <div className="flex gap-2">
                         <button onClick={() => setStep(2)} className="px-4 py-2 border bg-white rounded flex items-center gap-2"><Settings2 size={16}/> Edit Mapping</button>
                         <button onClick={() => printPDF(mappedData)} className="px-6 py-2 bg-brand-green text-white rounded font-bold shadow-lg hover:bg-green-900 transition flex items-center gap-2"><Printer size={18}/> Print Now</button>
                       </div>
                    </div>
                    
                    <div className="grid grid-cols-1 md:grid-cols-3 gap-8">{mappedData.flatMap((d, i) => Array(d.quantity).fill(0).map((_, j) => <div key={i+'-'+j}><LabelPreview data={d}/></div>))}</div>
                 </div>
               )}
            </main>
          </div>
        );
      };

      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(<App />);
    </script>
  </body>
</html>